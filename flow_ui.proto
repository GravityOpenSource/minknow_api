syntax = "proto3";

package ont.flow.ui;

////////////////////////////////
// Requirements and User Stories
////////////////////////////////

// - user wants some idea what stages are ahead. On first load the client
// displays some initial degree of navigation.
//
// - the workflow selected requires loading more reagents than there
// are ports on the cartridge meaning so there is an intermediate automatic
// stage to draw in the first set of reagents before allowing the user to put
// in the next set.
//
// - the workflow is selected and the user proceeds, but the user
// then changes their mind immediately and is able to go back to select an
// alternative workflow.
//
// - the server is running an automated step and the client should
// display the progress.
//
// - the client disconnects halfway through a UserStage. When it reconnects the
// client displays the current screen that the user was looking at and all the
// checkbox items previously selected are still selected.
//
// - the user confirms they have completed a step by ticking a
// checkbox. If the step is auto-detectable server-side there is onscreen
// confirmation.
//
// - two clients are connected. One client takes action to complete a step.
// Both clients are updated to the next step.

/////////////////
// Client message
/////////////////

// Client message
//
// Any selectable aspect of the client that requires a consequence server-side
// is associated with a unique id embodied in an Action message.
// To submit some choice the client should send the required Action message
// which will have been delivered already fully configured with a particular id
// via the Server message. Let's call it a "Return postcard" system.
// The Server is entirely responsible for setting the id of all Actions it
// passes to the client and carrying out the correct behaviour if it receives
// one back.
message Action
{
    int32 id = 1;
}


////////////////////////////
// Server message components
////////////////////////////

// Information about the running server
message Configuration
{
    string product_name = 1;
    string version = 2;
    string build = 3;
}

// General purpose actions that the client can send to the server at any time.
message GeneralActions
{
    // If sent by the client the server will respond with a full update. The
    // cacheable Data will be sent with clear flag set and will contain a
    // complete set of data for all stages. This will be exactly the same
    // message as if the client made a new connection.
    Action full_update = 1;
}

// Represents a prompt for a choice.
//
// The result of the choice here may affect the future Stages through which the
// user will be navigated. The main intention is that this used to allow the
// user to select a workflow.
message SelectionStage {
    message Choice {
        int32 id = 1;
        // Short title. E.g. "1D Barcoding"
        string name = 2;
        // Longer description. E.g. "Barcodes up to 4 separate samples before
        // pooling to run on the same flow cell."
        string description = 3;
    }
    int32 id = 1;

    // Set in order to mark that this stage is hooked onto part of the
    // navigation tree. Typically when a UI is rendering the navigation tree it
    // could in some way highlight the entry for the current stage. The mapping
    // is many to one, so that stages from different workflows can still be
    // associated with the same point on the navigation tree.
    int32 navigation_id = 2;

    repeated Choice choice = 3;
}

// Represents a consecutive sequence of prompting steps that a user would need
// to fulfil.
message UserStage {
    message Step {
        // Unique id for this step.
        int32 id = 1;
        // Short title for the step. e.g. "Load B/TA"
        string name = 2;
        // Longer description. e.g. "Load 1.1ul of Blunt/TA ligase"
        string description = 3;
        // A reference to a movie resource (or maybe other media) held client
        // side. A basename without extension.
        // It's entirely up to the client how to handle this - but presumably
        // the basename will be used to select a particular variation and
        // format from its own resources directory.
        string media = 4;
        // List of helpful tips for the user e.g. "Make sure not to pick up too
        // much excess on the pipette tip"
        repeated string hint = 5;

        message Check {
            enum Type {
                // The user has to tick a checkbox. The server has no way of
                // confirming the action so takes the user entirely at their
                // word.
                USERS_WORD = 0;

                // Automatically detected. The user does not have to manually
                // tick a checkbox.
                DETECTED = 1;
            }
            int32 id = 1;
            Type type = 2;
            string description = 3;
        }
        // List of checks. Typically these must all be ticked before the
        // progress to the next step is possible.
        repeated Check check = 6;

        // The resource path to which a websocket connection should be made to
        // receive image data for display. Only set if such data is relevant to
        // the step.  In particular on extract steps where live image data from
        // around the extract port is sent and should be displayed as part of
        // the step to assist the user.
        string image_stream = 7;
    }

    int32 id = 1;

    int32 navigation_id = 2;

    repeated Step step = 3;
}

// Represents a consecutive sequence of steps which will happen automatically.
message AutomaticStage {
    message Step {
        // Unique id for this step.
        int32 id = 1;
        // Short title for the step. E.g. "Fragment"
        string name = 2;
        // Longer description.
        string description = 3;
        // Approximate duration. For example, 2D Fragmentation takes ~180 seconds.
        uint32 estimated_seconds = 4;
    }
    int32 id = 1;

    int32 navigation_id = 2;

    repeated Step step = 3;
}

// Container for stages
//
// We could have arranged to use protobuf extensions to handle a 'Stage' as
// some kind of polymorphic type as a member of a Navigation Item.  It seems
// simpler however to have the Navigation object hold the information about
// over how stages are linked together without coupling to the stages by
// normalising through a unique stage_id. Then we merely have a simple separate
// container that exhaustively lists the stages under each type.
message Stages {
    repeated UserStage user = 1;
    repeated AutomaticStage automatic = 2;
    repeated SelectionStage selection = 3;
}

// A data structure to facilitate optional display of an evolving navigation.
//
// A functional Client is not required to use the data in Navigation messages.
// The Stages data and Status messages are sufficient to conduct a run. But for
// a better user experience this data can be used to provide the user with a
// summary view of what they have done, are doing and will need to do.
//
// Consider an initial message which describes some principle stages:
//
// 1 Setup device
// 2 Select workflow
// 3 Experiment preparation
// 4 Library preparation
// 5 Sample extraction
// 6 Disposal
//
// It's possible that stage 2 to select the workflow might affect the stages in
// step 3. It should be possible for a message to be received at a later stage,
// not just at first load, to update the navigation. For example: ...
// 3 Experiment preparation
//   3.1 Load first set of reagents
//   3.2 Draw in first set
//   3.3 Load second set of reagents
// ...

// The navigation is organised so rather than having a parent know its own
// children instead there is a Relation object that associates children with a
// parent_id. This means the parent Item itself does not need to be modified
// when adding children. In the case above a new a Navigation message
// containing a Relation with the three child items for parent item 3 would be
// sent.
message Navigation {

    message Item {
        // Items are referenced in a Relation by their id in order to formulate
        // the navigation tree structure. The id is also used by a
        // SelectionStage, UserStage or AutomaticStage to associate those
        // against the navigation item.
        int32 id = 1;
        string name = 2;
        string description = 3;
    }

    // Associates children with a parent
    message Relation {
        int32 parent_id = 1; ///< If 0 then it is the top level

        // These are ordered. When rendering items in the UI, if a number is to
        // be displayed next to the item name this ought to be the 1-based
        // index of the item's item id within this repeated child field.
        repeated int32 child = 2 [packed=true];
    }

    repeated Relation relation = 1;
    repeated Item item = 2;
}

// Cacheable part of server message.
//
// Normally the clear flag will be unset and component data of the message will
// be additive or identical to that of previous messages.  The client should
// merge that data with what it holds already.
// An efficient server implementation will not for example send a Navigation
// message containing an Item with the same id as an Item in a previous
// Navigation message. Yet in a less efficient case where it did send an Item
// with the same id, the Item should be identical.
//
// The principle is that this supports a system whereby as the user progresses
// through preparation they can always have an up-to-date picture of what lies
// ahead where possible.  A key time when very little is known is when the
// device is not yet plugged in. The user can only be given a high level
// idea of things they'll have to do. As soon as the device is plugged in and
// available workflows found more navigation can then be sent to the client via
// this message.
//
// There are a few more unusual and less restful cases:
// - if the device is unplugged and a different device is plugged in allowing
// for different workflows etc.
// - if the server has debug/dev configuration that are sent features which are
// changed at runtime.
// - if the user selects a workflow, which means the server will send new
// elements in the navigation tree, but then the user immediately goes back,
// which will likely be allowed if still in the very first step of the
// workflow, and selects a new workflow thus invalidating the current
// navigation tree.
// - the client issues a full_update Action.
//
// In these cases the clear flag will be set, and the other message fields will
// contain a full update. The client should clear its cache and repopulate.
message Data {
    bool clear = 1;
    Configuration configuration = 2;
    Stages stages = 3;
    Navigation navigation = 4;
    GeneralActions general_actions = 5;
}

// Dynamic part of server message
//
// Whereas a new Data message does not invalidate previously received Data
// messages unless the clear flag is set, a new Status message always
// invalidates the previous Status message.
message Status {
    // Id of currently active stage.
    // The Status message is agnostic of Navigation. There is no field to allow
    // the client to know directly which Item of the navigation tree it is
    // supposed to be on. It will have to search its navigation tree to find
    // the Item with the matching stage_id that matches this stage id.
    int32 current_stage_id = 1;

    message Step {
        int32 step_id = 1;

        // Rather than have a current_step field we just have a list of steps
        // and allow one to be current. This means we don't preclude a future
        // possibility of supporting two steps being current at the same time,
        // e.g. if two automatic steps can be run in parallel.
        bool is_current = 2;

        // Ordinarily if all the checks have the ticked field set to true then
        // the forward_action will be available. If the client sends this
        // Action then the next step will become the current one. If the
        // current step is the last step of the stage this should result in
        // moving to the next item and stage in the navigation.  For automatic
        // stages the value will be set when the stage is complete so that the
        // client can both show it is complete and enable a 'next' button.
        Action forward_action = 3;

        // If set and if this step is current, the client should enable a
        // 'back' button of some sort. Use of that button should be set to
        // trigger the client to send this Action message.
        Action back_action = 4;

        // For automatic steps of course the client should display the total
        // time elapsed/remaining, but this is also useful for user steps where
        // it might be handy to record or show how long the user spent doing a
        // step.
        uint32 elapsed_seconds = 5;

        message Check {
            int32 check_id = 1;
            // The state of the check. Will be set to true if, for Check items
            // of type USERS_WORD, the user triggered the client to send the
            // action to toggle it on or, for Check items of type DETECTED, the
            // system has confirmed the check.
            bool ticked = 2;
            // The toggle_action will be available for Check items of type
            // USERS_WORD so that the client can bind the means for a user to
            // change the state of the ticked field. If ticked is true, the
            // toggle action will untick, if ticked is false, the toggle action
            // will tick. There will be no toggle action present for Check
            // items of type DETECTED.
            Action toggle_action = 3;
        }

        repeated Check check = 6;
    }

    // The steps field will contain entries for the current stage if it is a
    // UserStage or an AutomaticStage. A SelectionStage has no steps.
    repeated Step step = 2;

    message Choice {
        int32 choice_id = 1;
        // If the user selects this choice the client should send this Action.
        Action select_action = 2;
    }
    repeated Choice choice = 3;
};


/////////////////
// Server message
/////////////////

// Server message
//
// The server pushes these update message to the client always. An update will be sent:
// - On connection
// - When it receives an Action from a client.
// - At any time during an automatic stage.
// - When a detectable alement of a user stage has happened.
//
message Update {
    // Incremental id.
    // Increased only if the Update message contains different content.
    // Possible use case is that as a result of a new client connection an
    // inefficient Server might simply send the same Update out to all clients
    // regardless of whether it sent it to existing clients before.
    int32 id = 1;

    // Cacheable data.
    // Unless it is explicitly asked to clear the client should accumulate all
    // data from this message with all previous Data messages.
    Data data = 2;

    // Dynamic data.
    // Invalidates previous status message.
    Status status = 3;
}

