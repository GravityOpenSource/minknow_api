syntax="proto3";

import "minknow/rpc/rpc_options.proto";

package ont.rpc.statistics;

service StatisticsService {
    // Tracks how much time has been spent in each channel state, aggregated across all the channels
    //
    // Will fail with FAILED_PRECONDITION if minknow is not acquiring data unless `wait_for_processing` is set to True,
    // then it will block and wait for data to start acquiring.
    //
    // The first response will give you all the data it can
    //
    // Since 1.13
    rpc stream_duty_time (StreamDutyTimeRequest) returns (stream StreamDutyTimeResponse) {}

    // Gets duty time information for a completed acquisition period.
    //
    // Currently, all time values must be given in multiples of 1 minute (it is recommended that the
    // time unit is set to minutes).
    //
    // Since 1.14
    rpc get_duty_time (GetDutyTimeRequest) returns (GetDutyTimeResponse) {}

    // A 2D histogram between basecall length and qscore
    //
    // The first response(s) will give you the latest data, then the responses after that will only 
    // contain buckets that have changed. The initial state may be sent over multiple messages
    //
    // Currently unimplemented
    //rpc stream_heatmap (StreamHeatmapRequest) returns (stream StreamHeatmapResponse) {}

    // Tracks experiment throughput across all channels over time
    //
    // The first response will give you all the data it can.
    //
    // The stream will end once the current acquisition period ends, and a caller will need to
    // reinvoke the rpc in order to get new throughput data.
    //
    // Since 1.14
    rpc stream_throughput (StreamCumulativeThroughputRequest) returns (stream StreamCumulativeThroughputResponse) {}

    // Gets cumultative throughput information for a completed acquisition period.
    //
    // Currently, all time values must be given in multiples of 1 minute (it is recommended that the
    // time unit is set to minutes).
    //
    // Since 1.14
    rpc get_throughput (GetCumulativeThroughputRequest) returns (GetCumulativeThroughputResponse) {}

    // A histogram of estimated read lengths (based on events)
    //
    // A whole new histogram will be sent everytime minknow polls for data (set by `poll_time`) and not just updates
    //
    // Since 3.0
    rpc stream_read_length_histogram (StreamReadLengthHistogramRequest) returns (stream StreamReadLengthHistogramResponse) {}

    // Gets the estimated read lengths for a particular acquisition period
    //
    // Since 3.0
    rpc get_read_length_histogram (GetReadLengthHistogramRequest) returns (GetReadLengthHistogramResponse) {}
}

enum TimeUnit {
    SECONDS = 0;
    MINUTES = 1;
}

message StreamDutyTimeRequest {
    // Defines (in seconds) the bucket period of the duty time data
    //
    // Will fail with INVALID_ARGUMENT if `step` is below 60
    // Will fail with INVALID_ARGUMENT if `step` is not a multiple of 60
    // TODO: maximum size?
    uint32 step = 1 [(rpc_required) = true];

    // Specify the start time of the data since the start time of the experiment (in seconds). If not specified then will return data since the start of the experiment
    //
    // Will fail with INVALID_ARGUMENT if not a multiple of `step`. (TODO: maybe round to closest value instead of failing?)
    //
    // For example, if this was set to 600 with a step of 60, then the first 10 buckets will not be returned
    // and the first bucket will be [600,660)
    uint32 start_time = 2;

    // Specify the end time of the data (in seconds). Call will return if the end time has been reached.
    // If the end time has not yet been reached, then the stream will continue until it has, and then return.
    // If not specified, then will stream forever
    // If `end_time` is 0, then this will count as not specified and will stream forever
    //
    // Will fail with INVALID_ARGUMENT if not a multiple of `step`
    // Will fail with INVALID_ARGUMENT if not more than `start_time`
    //
    // This specifies T1 for a bucket [T0, T1)
    uint32 end_time = 3;

    // If `wait_for_processing` is true, then will wait until minknow starts acquiring data instead
    // of returning with an error
    //
    // Defaults to false
    bool wait_for_processing = 4;

}

message StreamDutyTimeResponse {
    message Bucket {
        // Represents T0 for a bucket [T0, T1). So this will increase by 'step' for every bucket of duty time data
        //
        // Buckets are streamed whenever all channels have moved past a certain bucket point, so you will never
        // see the same bucket twice
        uint32 bucket = 1;

        // How much time (in samples) spent in this channel state, within this time bucket
        uint64 state_time = 2;
    }

    message ChannelStateData {
        repeated Bucket buckets = 1;
    }

    // Map between channel state names, and a list of bucketed duty time data
    map<string, ChannelStateData> channel_states = 1;
}

message GetDutyTimeRequest {
    // The acquisition id of the experiment.
    string run_id = 1 [(rpc_required) = true];

    // Defines the bucket period of the duty time data, in multiples of `time_unit`.
    uint32 step = 2 [(rpc_required) = true];

    // Specify the start time of the data since the start time of the experiment in multiples of
    // `time_unit`.
    //
    // Must be a multiple of `step`.
    //
    // If not specified then will return data since the start of the experiment.
    uint32 start_time = 3;

    // Specify the end time of the data to return in multiples of `time_unit`. Only data from before
    // this time will be returned.
    //
    // This does not need to be a multiple of `step` - you will get a smaller final bucket if it is
    // not.
    //
    // If not specified then will return all the data till the end of the experiment.
    // A time past the end of the experiment will be accepted, and treated in the same way.
    uint32 end_time = 4;

    // What unit of time are to use. Defaults to SECONDS
    //
    // This is used to interpret the other fields in this message as well as for the times in the
    // response message.
    TimeUnit time_unit = 5;
}

message GetDutyTimeResponse {
    message Bucket {
        // Represents T0 for a bucket [T0, T1). So this will increase by 'step' for every bucket of duty time data
        //
        // Buckets are streamed whenever all channels have moved past a certain bucket point, so you will never
        // see the same bucket twice
        uint32 bucket = 1;

        // How much time (in samples) spent in this channel state, within this time bucket
        uint64 state_time = 2;
    }

    message ChannelStateData {
        repeated Bucket buckets = 1;
    }

    // Map between channel state names, and a list of bucketed duty time data
    map<string, ChannelStateData> channel_states = 1;
}

enum BucketValueType {
    // Numbers for use in example below
    // Reads: 5
    // Events for each read: [20, 100, 30, 60, 110]
    // Events to base ratio: 2.0

    // Counts only total number of reads
    //
    // Using example above, the bucket value would be 5
    READ_COUNTS = 0;

    // Calculates the sum of the event counts for all the reads
    //
    // Using the example above, the bucket value would be 320
    EVENTS = 1;

    // Estimates the number of bases based on the events and an event to base ratio
    //
    // Using the example above, the bucket value would be 160
    ESTIMATED_BASES = 2;

    // This is the actual, basecalled number of bases for a read. As basecalling takes time
    // then this may be delayed in comparision to the other types
    BASECALLED_BASES = 3;
}

message StreamReadLengthHistogramRequest {
    // Sets the desired width of the buckets. The actual width may not be the number set here
    //
    // If not set, then will set the minimum width possible
    uint32 bucket_width = 1;

    // Sets the point of the leftmost bucket
    //
    // The leftmost bucket of the upscaled histogram will be the one that contains this value.
    // The histogram will contain data for values starting at the minimum value for this bucket.
    // Thus, the start value of the histogram may be lower than the value specified by this
    // field.
    //
    // By default will start from 0
    uint32 start = 2;

    // Sets the point of the rightmost bucket
    //
    // If a non-zero value is specified, then the rightmost bucket of the upscaled histogram will be the one that contains this value.
    // The histogram will contain data for values ending at the maximum value for this bucket.
    // Thus, the end value of the histogram may be higher than the value specified by this
    // field.
    //
    // If zero is specified, then the rightmost bucket will be the highest one which has data stored in it.
    // This will be freshly determined with every streamed response.
    // This means that the number of buckets can shrink or grow between 2 responses.
    //
    // Be default, this will be 0
    uint32 end = 3;

    // Determines what data is returned in the buckets
    //
    // See `BucketValueType` definition for a concrete example of what each type represents
    BucketValueType bucket_value_type = 4;

    // Sets how long minknow will take to poll the data and return a response, specified
    // in [time_unit]
    uint32 poll_time = 5;

    // What unit of time are to use. Defaults to SECONDS
    //
    // This is used to interpret the other fields in this message as well as for the times in the
    // response message.
    TimeUnit time_unit = 6;
}

message StreamReadLengthHistogramResponse {

    // Array of data for the histogram buckets.
    // The values will be of the type represented by `bucket_value_type`
    repeated uint64 buckets = 1;

    // The size of the bucket
    uint32 width = 2;

    // Note that this can be different from what is requested if the type requested is not available for some reason 
    // (e.g. requested ESTIMATED_BASES but events_to_base ratio is not set in minknow)
    BucketValueType bucket_value_type = 3;
    
    // The lowest value in the range covered by the histogram
    // (and, therefore, also the lowest value in the range covered by the first bucket of the histogram)
    uint32 min_val = 4;    
}

message GetReadLengthHistogramRequest {
    // The acquisition id of the experiment
    string run_id = 1 [(rpc_required) = true];

    // Sets the desired width of the buckets. The actual width may not be the number set here
    //
    // If not set, then will set the minimum width possible
    uint32 bucket_width = 2;

    // Sets the point of the leftmost bucket
    //
    // The leftmost bucket of the upscaled histogram will be the one that contains this value.
    // The histogram will contain data for values starting at the minimum value for this bucket.
    // Thus, the start value of the histogram may be lower than the value specified by this
    // field.
    //
    // By default will start from 0
    uint32 start = 3;

    // Sets the point of the rightmost bucket
    //
    // If a non-zero value is specified, then the rightmost bucket of the upscaled histogram will be the one that contains this value.
    // The histogram will contain data for values ending at the maximum value for this bucket.
    // Thus, the end value of the histogram may be higher than the value specified by this
    // field.
    //
    // If zero is specified, then the rightmost bucket will be the highest one which has data stored in it.
    //
    // Be default, this will be 0
    uint32 end = 4;

    // Determines what data is returned in the buckets
    //
    // See `BucketValueType` definition for a concrete example of what each type represents.
    BucketValueType bucket_value_type = 5;
}

message GetReadLengthHistogramResponse {

    // Array of data for the histogram buckets.
    // The values will be of the type represented by `bucket_value_type`
    repeated uint64 buckets = 1;

    // The size of the bucket
    uint32 width = 2;

    // Note that this can be different from what is requested if the type requested is not available for some reason 
    // (e.g. requested ESTIMATED_BASES but events_to_base ratio is not set in minknow)
    BucketValueType bucket_value_type = 3;
    
    // The lowest value in the range covered by the histogram
    // (and, therefore, also the lowest value in the range covered by the first bucket of the histogram)
    uint32 min_val = 4;    
}

message StreamHeatmapRequest {
    bool is_cumulative = 1;
}

message StreamHeatmapResponse {
    message Bucket {
        // Represents T0 for a bucket [T0, T1) for basecall length
        uint32 basecall_length_bucket = 1;

        // Represents T0 for a bucket [T0, T1) for qscore
        float qscore_bucket = 2;

        // Setting `is_cumulative` to false will give `read_count`, setting to true will return `read_length`
        //
        // `read_count` is the number of reads we have seen in this bucket, so if this was bucket 0 and
        // and there has been a read with length 30 and another with 20, then `read_count` will be 2
        //
        // `read_length` is the cumulative read length of the bucket. So using the previous example, 
        // `read_length` will be 50
        oneof read_type {
            uint32 read_count = 3;
            uint32 read_length = 4;
        }
    }

    message Group {
        // The width of the bucket for the basecall length.
        uint32 basecall_length_width = 1;

        // The width of the bucket for the qscore
        float qscore_width = 2;

        repeated Bucket buckets = 3;
    }

    repeated Group bucket_groups = 1;
}

message StreamCumulativeThroughputRequest {
    // Defines (in seconds) the bucket period of the throughput
    //
    // The minimum size for `step` is 60
    // TODO: maximum size?
    uint32 step = 1 [(rpc_required) = true];

    // Specify the start time of the throughput data (in seconds). If not specified then will return data since the start of the experiment
    //
    // Will fail with INVALID_ARGUMENT if not a multiple of `step`. (TODO: maybe round to closest value instead of failing?)
    //
    // For example, if this was set to 600 with a step of 60, then the first 10 buckets will not be returned
    // and the first bucket will be [600,660)
    uint32 start_time = 2;

    // Specify the end time of the data (in seconds). Call will return if the end time has been reached.
    // If the end time has not yet been reached, then the stream will continue until it has, and then return.
    // If not specified, then will stream forever
    //
    // Will fail with INVALID_ARGUMENT if not a multiple of `step`
    // Will fail with INVALID_ARGUMENT if not more than `start_time`
    //
    // This specifies T1 for a bucket [T0, T1)
    uint32 end_time = 3;

    // If `wait_for_processing` is true, then will wait until minknow starts acquisiting data instead of returning with an error
    //
    // Defaults to false
    bool wait_for_processing = 4;
}

message CumulativeThroughputBucket {
    // Represents T0 for a bucket [T0, T1). So this will increase by 'step' for every bucket of throughput data
    uint32 bucket = 1;

    // Fields here are intended to mirror acquisition.AcquisitionYieldSummary
    // TODO (major version change): unify this structure with statistics.CumulativeThroughputBucket

    // Number of reads produced by the experiment
    uint32 read_count = 2;

    // Number of reads the live basecaller has called so far.
    //
    // Note: This data will remain at zero if MinKNOW is not basecalling.
    uint32 basecalled_pass_read_count = 3;

    // Number of reads the live basecaller has failed calling so far.
    //
    // Note: This data will remain at zero if MinKNOW is not basecalling.
    uint32 basecalled_fail_read_count = 4;

    // Number of reads the live basecaller has skipped so far.
    //
    // Note: This data will remain at zero if MinKNOW is not basecalling.
    uint32 basecalled_skipped_read_count = 5;

    // Number of samples in all reads produced.
    uint64 selected_raw_samples = 6;

    // Number of minknow events in all reads produced.
    uint64 selected_minknow_events = 7;

    // Number of bases (estimated from all selected reads produced) produced.
    uint64 estimated_selected_bases = 8;

    // Number of bases called using live basecalling.
    //
    // Note: This data will remain at zero if MinKNOW is not basecalling.
    uint64 basecalled_bases = 9;

    // Number of bases called using live basecalling.
    //
    // Note: This data will remain at zero if MinKNOW is not basecalling.
    uint64 basecalled_samples = 10;
}

message StreamCumulativeThroughputResponse {
    repeated CumulativeThroughputBucket buckets = 1;
}

message GetCumulativeThroughputRequest {
    // The acquisition id of the experiment.
    string run_id = 1 [(rpc_required) = true];

    // Defines the bucket period of the cumulative throughput data, in multiples of `time_unit`.
    uint32 step = 2 [(rpc_required) = true];

    // Specify the start time of the data since the start time of the experiment in multiples of
    // `time_unit`.
    //
    // Must be a multiple of `step`.
    //
    // If not specified then will return data since the start of the experiment.
    uint32 start_time = 3;

    // Specify the end time of the data to return in multiples of `time_unit`. Only data from before
    // this time will be returned.
    //
    // This does not need to be a multiple of `step` - you will get a smaller final bucket if it is
    // not.
    //
    // If not specified then will return all the data till the end of the experiment.
    // A time past the end of the experiment will be accepted, and treated in the same way.
    uint32 end_time = 4;

    // What unit of time are to use. Defaults to SECONDS
    //
    // This is used to interpret the other fields in this message as well as for the times in the
    // response message.
    TimeUnit time_unit = 5;
}

message GetCumulativeThroughputResponse {
    repeated CumulativeThroughputBucket buckets = 1;
}
